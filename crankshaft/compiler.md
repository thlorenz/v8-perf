<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](http://doctoc.herokuapp.com/)*

- [v8 Compiler](#v8-compiler)
  - [Components](#components)
    - [Base Compiler](#base-compiler)
    - [Runtime Profiler](#runtime-profiler)
    - [Optimizing Compiler](#optimizing-compiler)
    - [Deoptimization Support](#deoptimization-support)
  - [Optimized Code vs. Inline Caches and Unoptimized Code](#optimized-code-vs-inline-caches-and-unoptimized-code)
    - [Full Compiler](#full-compiler)
    - [Inline Caches](#inline-caches)
    - [Monomorphism vs. Polymorphism](#monomorphism-vs-polymorphism)
      - [Considerations](#considerations)
    - [Optimizing Compiler](#optimizing-compiler-1)
    - [Deoptimization](#deoptimization)
    - [Causes for Deoptimization](#causes-for-deoptimization)
      - [Modifying Object Shape](#modifying-object-shape)
        - [Considerations](#considerations-1)
  - [Efficiently Representing Values and Tagging](#efficiently-representing-values-and-tagging)
    - [Considerations](#considerations-2)
  - [Arrays](#arrays)
    - [Fast Elements](#fast-elements)
      - [Characteristics](#characteristics)
    - [Dictionary Elements](#dictionary-elements)
      - [Characteristics](#characteristics-1)
    - [Double Array Unboxing](#double-array-unboxing)
    - [Typed Arrays](#typed-arrays)
      - [Float64Array](#float64array)
    - [Considerations](#considerations-3)
  - [Resources](#resources)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# v8 Compiler

## Components

### Base Compiler 

- is used for all code initially
- generates code quickly without heavy optimizations
- compilation with the base compiler is very fast generates little code

### Runtime Profiler 

- monitors the running system and identifies hot code

### Optimizing Compiler 

- recompiles and optimizes hot code identified by the runtime profiler
- uses static single assignment form to perform optimizations
  - loop-invariant code motion
  - linear-scan register allocation
  - inlining.
- optimization decisions are based on type information collected while running the code produced by the base compiler

### Deoptimization Support 

- allows the optimizing compiler to be optimistic in the assumptions it makes when generating code
- deoptimization support allows to bail out to the code generated by the base compiler if the assumptions in the
  optimized code turn out to be too optimistic

## Optimized Code vs. Inline Caches and Unoptimized Code

[watch](http://youtu.be/VhpdsjBUS3g?t=18m53s)
[watch](http://youtu.be/UJPdhx5zTaw?t=26m30s)

### Full Compiler

[slide](http://v8-io12.appspot.com/index.html#54)

- generates code for any JavaScript
- all code starts unoptimized
- initial (quick) JIT 
- is not great and knows (almost) nothing about types
- needed to start executing code ASAP
- uses Inline Caches (ICs) to refine knowledge about types at runtime

### Inline Caches

[slide](http://v8-io12.appspot.com/index.html#55)

[Inline Caches implemented in JavaScript](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)

- gather knowledge about types while program runs
- **type dependent** code for operations given specific hidden classes as inputs
- 1. validate type assumptions (are hidden classes as expected)
- 2. do work
- change at runtime via backpatching as more types are discovered to generate new ICs
  [watch](http://youtu.be/UJPdhx5zTaw?t=28m44s) | [slide](http://v8-io12.appspot.com/index.html#56)

Inline Caches alone without optimizing compiler step make huge performance difference (20x speedup).

### Monomorphism vs. Polymorphism

[watch](http://youtu.be/UJPdhx5zTaw?t=31m30s) | [slide](http://v8-io12.appspot.com/index.html#61)

- operations are monomorphic if hidden classes of arguments are **always** same
- all others are polymorphic at best and megamorphic at worst
- monomorphic operations are easier optimized

#### Considerations

- prefer monomorphic over polymorphic functions wherever possible

### Optimizing Compiler

[watch](http://youtu.be/UJPdhx5zTaw?t=33m12s) | [slide](http://v8-io12.appspot.com/index.html#65)

- if function executes a lot it becomes **hot**
- hot function is re-compiled with optimizing compiler
  - optimistically 
  - lots of assumptions made from the calls made to that function so far
  - type information takend from ICs
  - operations get inlined speculatively using historic information
  - monomorphic functions/constructors can be inlined entirely
  - inlining allows even further optimizations

### Deoptimization

[watch](http://youtu.be/UJPdhx5zTaw?t=36m50s) | [slide](http://v8-io12.appspot.com/index.html#78)

- optimizations are speculative and assumptions are made
- if assumption is violated
  - function deoptimized
  - execution resumes in full compiler code
  - in short term execution slows down
  - normal to occur
  - more info about about function collected
  - *better* optimization attempted
  - if assumptions are violated again, deoptimized again and start over 
- too many deoptimizations cause function to be sent to *deoptimization hell*
  - considered not optimizable and no optimization is **ever** attempted again
- certain constructs like `try/catch` are considered not optimizable and functions containing it go straight to
  *deoptimization hell* due to **bailout** [watch](http://youtu.be/UJPdhx5zTaw?t=35m23s)

None of this can be diagnosed with Chrome Devtools at this point.

### Causes for Deoptimization

#### Modifying Object Shape

[watch](http://youtu.be/VhpdsjBUS3g?t=21m00s)

- added fields (order matters) to object generate id of hidden class
- adding more fields later on generates new class id which results in code using Point that now gets Point' to be
  deoptimized

[watch](http://youtu.be/VhpdsjBUS3g?t=21m45s)
[watch](http://youtu.be/UJPdhx5zTaw?t=12m18s)

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}

var p = new Point(1, 2); // => hidden Point class created

// ....

p.z = 3;                 // => another hidden class (Point') created
```

- `Point` class created, code still deoptimized
- functions that have `Point` argument are optimized
- `z` property added which causes `Point'` class to be created
- functions that get passed `Point'` but were optimized for `Point` get deoptimized
- later functions get optimized again, this time supporting `Point` and `Point'` as argument
- [detailed explanation](http://v8-io12.appspot.com/index.html#30)

##### Considerations

- avoid hidden class changes
- initialize all members in **constructor function** and **in the same order**

## Efficiently Representing Values and Tagging

[watch](http://youtu.be/UJPdhx5zTaw?t=15m35s) | [slide](http://v8-io12.appspot.com/index.html#34)

- v8 passes around 32bit numbers to represent all values
- bottom bit reserved as tag to signify if value is a SMI (small integer) or a pointer to an object

[watch](http://youtu.be/UJPdhx5zTaw?t=10m05ss) | [slide](http://v8-io12.appspot.com/index.html#35)

```
| object pointer              | 1 |

or

| 31-bit-signed integer (SMI) | 0 |
```

- numbers bigger than 31 bits are boxed 
- stored inside an object referenced via a pointer 
- adds extra overhead (at a minimum an extra lookup)

### Considerations

- prefer SMIs for numeric values whenever possible

## Arrays

[watch](http://youtu.be/UJPdhx5zTaw?t=17m25s) | [slide](http://v8-io12.appspot.com/index.html#38)

v8 has two methods for storing arrays.

### Fast Elements

- compact keysets
- linear storage buffer

#### Characteristics

- contiguous (non-sparse) 
- `0` based
- smaller than 64K

### Dictionary Elements

- hash table storage
- slow access

#### Characteristics

- sparse
- large

### Double Array Unboxing

[watch](http://youtu.be/UJPdhx5zTaw?t=20m20s) | [slide](http://v8-io12.appspot.com/index.html#45)

- Array's hidden class tracks element types
- if all doubles, array is unboxed
  - wrapped objects layed out in linear buffer of doubles
  - each element slot is 64-bit to hold a double
  - SMIs that are currently in Array are converted to doubles
  - very efficient access
  - storing requires no allocation as is the case for boxed doubles
  - causes hidden class change
- careless array manipulation may cause overhead due to boxing/unboxing [watch](http://youtu.be/UJPdhx5zTaw?t=21m50s) |
  [slide](http://v8-io12.appspot.com/index.html#47)

### Typed Arrays

[blog](http://mrale.ph/blog/2011/05/12/dangers-of-cross-language-benchmark-games.htm) |
[spec](https://www.khronos.org/registry/typedarray/specs/latest/)

- difference is in semantics of indexed properties
- v8 uses unboxed backing stores for such typed arrays

#### Float64Array

- gets 64-bit allocated for each element

### Considerations

- don't pre-allocate large arrays (`>64K`), instead grow as needed, to avoid them being considered sparse
- do pre-allocate small arrays to correct size to avoid allocations due to resizing
- don't delete elements
- don't load uninitialized or deleted elements [watch](http://youtu.be/UJPdhx5zTaw?t=19m30s) |
  [slide](http://v8-io12.appspot.com/index.html#43)
- use literal initializer for Arrays with mixed values
- don't store non-numeric valuse in numeric arrays
  - causes boxing and efficient code that was generated for manipulating values can no longer be used
- use typed arrays whenever possible

## Resources

- [video: accelerating oz with v8](https://www.youtube.com/watch?v=VhpdsjBUS3g) |
  [slides](http://commondatastorage.googleapis.com/io-2013/presentations/223.pdf)
- [video: breaking the javascript speed limit with v8](https://www.youtube.com/watch?v=UJPdhx5zTaw) |
  [slides](http://v8-io12.appspot.com/index.html#1)
- [chromium blog announcement 2010](http://blog.chromium.org/2010/12/new-crankshaft-for-v8.html)
- [mraleph: dangers of cross language
  benchmarks 5/2011](http://mrale.ph/blog/2011/05/12/dangers-of-cross-language-benchmark-games)
- [wingo: closer look at crankshaft 8/2011](http://wingolog.org/archives/2011/08/02/a-closer-look-at-crankshaft-v8s-optimizing-compiler)
- [wingo: inside full-codegen 4/2013](http://wingolog.org/archives/2013/04/18/inside-full-codegen-v8s-baseline-compiler)
- [tour of crankshaft 4/2013](http://jayconrod.com/posts/54/a-tour-of-v8-crankshaft-the-optimizing-compiler)
